version: 0.2

env:
  variables:
    TF_VERSION: "1.7.5"
    TG_VERSION: "0.67.6"
    TG_PARALLELISM: "10"   # tune if needed

phases:
  install:
    commands:
      - set -euo pipefail
      - echo "[INSTALL] Using region: ${AWS_DEFAULT_REGION}"
      - echo "[INSTALL] Installing unzip..."
      - yum -y install unzip >/dev/null
      - echo "[INSTALL] Installing Terraform ${TF_VERSION}..."
      - curl -fsSL -o /tmp/tf.zip https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip
      - unzip -o /tmp/tf.zip -d /usr/local/bin >/dev/null
      - terraform -version
      - echo "[INSTALL] Installing Terragrunt v${TG_VERSION}..."
      - curl -fsSL -o /usr/local/bin/terragrunt https://github.com/gruntwork-io/terragrunt/releases/download/v${TG_VERSION}/terragrunt_linux_amd64
      - chmod +x /usr/local/bin/terragrunt
      - terragrunt -version
      - echo "[INSTALL] Installing jq..."
      - yum -y install jq >/dev/null
  pre_build:
    commands:
      - echo "[PRE] Locating latest intake folder under live/sandbox..."
      - |
        cd "$CODEBUILD_SRC_DIR"
        ls -la
        INTAKE_DIR="$(ls -1d live/sandbox/intake_id_* 2>/dev/null | sort -V | tail -n1 || true)"
        if [ -z "${INTAKE_DIR}" ]; then
          echo "[ERROR] No live/sandbox/intake_id_* directory found in repo." >&2
          exit 1
        fi
        echo "[PRE] Selected intake dir: ${INTAKE_DIR}"
        JSON_PATH="${INTAKE_DIR}/inputs.json"
        if [ ! -f "${JSON_PATH}" ]; then
          echo "[ERROR] inputs.json not found at ${JSON_PATH}" >&2
          exit 1
        fi
        echo "[PRE] inputs.json:"
        cat "${JSON_PATH}" | jq .
      - |
        echo "[PRE] Extracting destination assume role (assume_role_arn || iam_role)..."
        ROLE_ARN="$(jq -r '.assume_role_arn // .iam_role // empty' "${JSON_PATH}")"
        if [ -n "${ROLE_ARN}" ]; then
          echo "[PRE] Assuming role: ${ROLE_ARN}"
          CREDS_JSON="$(aws sts assume-role --role-arn "${ROLE_ARN}" --role-session-name SandboxProvision --output json)"
          export AWS_ACCESS_KEY_ID="$(echo "${CREDS_JSON}" | jq -r .Credentials.AccessKeyId)"
          export AWS_SECRET_ACCESS_KEY="$(echo "${CREDS_JSON}" | jq -r .Credentials.SecretAccessKey)"
          export AWS_SESSION_TOKEN="$(echo "${CREDS_JSON}" | jq -r .Credentials.SessionToken)"
          aws sts get-caller-identity --query Arn --output text
        else
          echo "[PRE] No role provided in inputs.json; using current credentials."
        fi
  build:
    commands:
      - echo "[BUILD] Starting APPLY from ${INTAKE_DIR} (excluding versions/ and decommission/)..."
      - |
        cd "${INTAKE_DIR}"
        # Init (idempotent) to avoid first-run backend prompts
        terragrunt run-all init -reconfigure --terragrunt-non-interactive --terragrunt-parallelism ${TG_PARALLELISM} || true
        terragrunt run-all apply \
          --terragrunt-non-interactive \
          --terragrunt-parallelism ${TG_PARALLELISM} \
          --terragrunt-exclude-dir versions \
          --terragrunt-exclude-dir decommission \
          -auto-approve
      - |
        echo "[BUILD] Checking for decommission modules..."
        if [ -d "decommission" ] && find decommission -type f -name terragrunt.hcl -print -quit | grep -q . ; then
          echo "[BUILD] decommission/ found with modules. Running DESTROY inside decommission/..."
          cd decommission
          terragrunt run-all init -reconfigure --terragrunt-non-interactive --terragrunt-parallelism ${TG_PARALLELISM} || true
          terragrunt run-all destroy \
            --terragrunt-non-interactive \
            --terragrunt-parallelism ${TG_PARALLELISM} \
            -auto-approve
          cd ..
        else
          echo "[BUILD] No decommission work detected. Skipping destroy."
        fi
  post_build:
    commands:
      - |
        echo "[POST] Writing build status artifact..."
        mkdir -p build-status
        cat > build-status/result.json <<'JSON'
        { "status": "success", "message": "Apply (and optional decommission destroy) completed" }
        JSON
artifacts:
  files:
    - build-status/result.json
  name: BuildArtifact
  discard-paths: yes
